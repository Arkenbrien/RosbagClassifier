%==========================================================================
%                       Travis Moleski/Rhett Huston
%
%                     FILE CREATION DATE: 10/19/2022
%
%                      Bulk_Training_Data_Extract.m
%
% This program looks at a ROSBAG generated by the Ohio University van and
% sequentially grabs training data based on which rings fall inside a roi
%
%==========================================================================

%% Clear & Setup Workspace
clc; clear; close all
format compact

% warning('CHECK THESE VARS: xy_roi Filename xyzir_front xyzir_REAR!!!!!!!')
% disp('Pausing until ready...')
% pause

%% Options

roi_select = 1;

%% Variable Initiation
LiDAR_Ref_Frame             = [0; 1.584; 1.444];
IMU_Ref_Frame               = [0; 0.336; -0.046];

% Correction frame:         LiDAR_Ref_Frame - IMU_Ref_Frame [Y X Z]
gps_to_lidar_diff           = [(LiDAR_Ref_Frame(1) - IMU_Ref_Frame(1)), (LiDAR_Ref_Frame(2) - IMU_Ref_Frame(2)), (LiDAR_Ref_Frame(3) - IMU_Ref_Frame(3))]; 

raw_data_export = {};


%% roi/rosbag PAIRS - 1 ROI per file

% Gravel Lot 1
% roi_file = '/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/man_roi/Manual_Classified_PCD_arc_width_controlol.mat.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/gravel_lot/2023-03-09-14-46-23.bag';
% terrain_opt = 1;

% Gravel Lot 2, 3
% roi_file = '/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/man_roi/Manual_Classified_PCD_gravel_lot_2_2rois.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/gravel_lot/2023-03-14-13-12-31.bag';
% terrain_opt = 1;
% roi_select = 2; % 1, 2

% Lawn Grass 1
% roi_file = '/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/TRAINING_PCD_EXPORT/Manual_Classified_PCD_2022-10-20-10-17-31_CHIP_ALL_for_grass.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/Armitage_Shortened_Bags/2022-10-20-10-17-31_CHIP.bag';
% terrain_opt = 4;

% Lawn Grass 2
% roi_file = '/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/TRAINING_PCD_EXPORT/Manual_Classified_PCD_2022-10-20-10-21-54_CHIP_ALL_for_grass.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/Armitage_Shortened_Bags/2022-10-20-10-21-54_CHIP.bag';
% terrain_opt = 4;

% Pavement 1, 2
% roi_file = '/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/man_roi/Manual_Classified_PCD_pavement_1_roi.mat.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/03_13_2023_shortened_coach_sturbois/2023-03-13-10-56-38.bag';
% terrain_opt = 5;
% roi_select = 2; %1,2

% Lawn Grass 3
% roi_file = '/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/man_roi/Manual_Classified_PCD_blue_route_grass_roi.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/blue_short/2023-03-15-14-09-13.bag';
% terrain_opt = 4;
% roi_select = 1;

% Pavement 3, 4 - blue_route
% roi_file = '/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/man_roi/Manual_Classified_PCD_blue_route_asphalt_roiz.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/blue_short/2023-03-15-14-09-13.bag';
% terrain_opt = 5;
% roi_select = 3; %1,2,3

% Gravel Lot Interception files
% Down 1
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Down/03_29_14_54_16_all.pcd_20232103130404.mat'; terrain_opt = 5;
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Down/2023-03-29-14-54-16.bag';
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Down/foliage_grab_2FROMFILE2023-03-29-14-54-16.pcd_20230904140433.mat'; terrain_opt = 3;
% roi_select = 2;

% Down 2
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Down/Down_2_03_29_14_57_17_25to150.pcd.pcd_20233803100451.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Down/2023-03-29-14-57-17.bag';

% Down 3
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Down/Down_3_29_14_59_48_250to400.pcd.pcd_20234003100412.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Down/2023-03-29-14-59-48.bag';

% Up 1
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Up/Up_1_29_14_53_21_1tolen.pcd_20234103100425.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Up/2023-03-29-14-53-21.bag';

% Up 2
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Up/2023-03-29-14-55-44.bag.mat'; terrain_opt = 5;
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Up/foliage_grab_FROM_FILE_2023-03-29-14-55-44_20230104140446.mat'; terrain_opt = 3;
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Up/2023-03-29-14-55-44.bag';
% roi_select = 2;

% Up 3
% roi_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Up/Up_3_14_58_13_325to450.pcd.pcd_20234303100447.mat';
% bag_file = '/media/autobuntu/chonk/chonk/DATA/chonk_ROSBAG/lot_intercept/Up/2023-03-29-14-58-13.bag';

%=========================================================================%


%% Load Stuff

% Load the rosbag into the workspace
disp('Loading ROSBAG')
bag = rosbag(bag_file);
disp('ROSBAG Loaded')

% Topics
disp('Loading Messages...')
topics = bag.AvailableTopics;
          
disp('Loading LIDAR Messages...')
lidar_topic = select(bag,'Topic','velodyne_points');
lidar_msgs = readMessages(lidar_topic, 'DataFormat', 'struct');

disp('Loading GPS Messages... ')
gps_topic = select(bag,'Topic','/gps/gps');
gps_msgs = readMessages(gps_topic, 'DataFormat', 'struct');

disp('Messages Loaded')

% Load the ROI file
load(roi_file);

%% MCA Terrain Select

% disp('Select terrain type')
% dlg_list                    = {'Gravel', 'Chipseal', 'Foliage', 'Grass', 'Asphalt'};
% [terrain_opt,~]           = listdlg('ListString', dlg_list,'SelectionMode','single');

%% Save Location

time_now        = datetime("now","Format","uuuuMMddhhmmss");
time_now        = datestr(time_now,'yyyyMMddhhmmss');

[~, bag_name] = fileparts(bag_file);

if terrain_opt == 1
    save_folder = "/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/TRAINING_DATA/01_RDF_Training_Data_Extraction_Export/" + string(bag_name)
    terrain_type = 'gravel';
elseif terrain_opt == 2
    save_folder = "/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/TRAINING_DATA/01_RDF_Training_Data_Extraction_Export/" + string(bag_name)
    terrain_type = 'chipseal';
elseif terrain_opt == 3
    save_folder = "/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/TRAINING_DATA/01_RDF_Training_Data_Extraction_Export/" + string(bag_name)
    terrain_type = 'foliage';
elseif terrain_opt == 4
    save_folder = "/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/TRAINING_DATA/01_RDF_Training_Data_Extraction_Export/" + string(bag_name)
    terrain_type = 'grass';
elseif terrain_opt == 5
    save_folder = "/media/autobuntu/chonk/chonk/git_repos/Rural-Road-Lane-Creator/Random_Forest/TRAINING_DATA/01_RDF_Training_Data_Extraction_Export/" + string(bag_name)
    terrain_type = 'asphalt';
end

mkdir(save_folder)
addpath(save_folder)

%% More Var Init

% cloud_break                 = 150;
cloud_break                 = length(lidar_msgs);
gps_pos_store               = zeros(cloud_break,3);
lidar_pos_store             = gps_pos_store;

% minimum/maximum distance cut-off
min_dist                    = 2.25;
max_dist                    = 10;

% % Closest 2 rings
% ring_min                    = 10;
% ring_max                    = 1;
% 
% % Furthest 10 rings - foliage
% ring_min                    = 31;
% ring_max                    = 20;

% Closest 8 rings - grass
% ring_min = 7;
% ring_max = 1;

% Closest 3-8 rings - grass 2022-10-20-10-21-54
% ring_min = 7;
% ring_max = 3;

% All Rings
ring_min = 32;
ring_max = 1;

% RANSAC - MATLAB
maxDistance                 = 0.5;

%% Checkaronis

manual_classifier_pcd_display(roi_file, lidar_msgs, gps_msgs, ring_min, ring_max, min_dist, max_dist, terrain_opt, roi_select)

disp('Waiting until ready!')
pause

close all

%% Timestamps

% Matching timestamps
[indexes, fromTimes, toTimes, diffs] = matchTimestamps(lidar_msgs, gps_msgs);

%Find which GPS message matches the first scan
matchedLidar                = lidar_msgs{1};
matchedGps_init             = gps_msgs{indexes(1)};

%% Initilizing the starting point
% Select reference point as first GPS reading (local)
origin = [matchedGps_init.Latitude, matchedGps_init.Longitude, matchedGps_init.Altitude];

% Setting the offset from the gps orientation to the lidar
% takes gps emu to local frame of lidar
gps2lidar = [ cosd(90) sind(90) 0;
             -sind(90) cosd(90) 0;
             0       0          1]; 
         
% Setting the (gps_to_lidar_diff) offset from the lidar offset to the gps
LidarOffset2gps = [ cosd(90) -sind(90)  0;
                    sind(90)  cosd(90)   0;
                    0        0           1]; 

%% Doing the data
fprintf('Max time delta is %f sec \n',max(abs(diffs)));

h = waitbar(0, "Grabbing the dataz...");
for cloud = 1:length(lidar_msgs)
    
    %% Grabbing Data
    
    % Reading the current point cloud and matched gps coord
    current_cloud               = lidar_msgs{cloud};
    matched_stamp               = gps_msgs{indexes(cloud)};
    
    % Converting the gps coord to xyz (m)
    [xEast, yNorth, zUp]        = latlon2local(matched_stamp.Latitude, matched_stamp.Longitude, matched_stamp.Altitude, origin);
    
    % Grabbing the angles
    roll                        = matched_stamp.Roll;
    pitch                       = matched_stamp.Pitch;
    yaw                         = matched_stamp.Track+180;
    
    %% Rectifying Frames
     
    % Creating the rotation matrix
    rotate_update               = rotz(90-yaw)*roty(roll)*rotx(pitch);
     
    % Comment Here
    groundTruthTrajectory       = [xEast, yNorth, zUp] * gps2lidar ;
    
    % Comment Here
    gps_to_lidar_diff_update    = gps_to_lidar_diff * LidarOffset2gps * rotate_update;

    % Comment Here
    LidarxEast                  = groundTruthTrajectory(1)  + gps_to_lidar_diff_update(1);
    LidaryNorth                 = groundTruthTrajectory(2)  + gps_to_lidar_diff_update(2);
    LidarzUp                    = groundTruthTrajectory(3)  + gps_to_lidar_diff_update(3);

    % Comment here
    groundTruthTrajectory       = groundTruthTrajectory;
    lidarTrajectory             = [LidarxEast, LidaryNorth, LidarzUp];
    
    % Reading the current cloud for xyz, intensity, and ring (channel) values
    xyz_cloud                   = rosReadXYZ(current_cloud);
    intensities                 = rosReadField(current_cloud, 'intensity');
    ring                        = rosReadField(current_cloud, 'ring');
    xyz_cloud(:,4)              = intensities;
    xyz_cloud(:,5)              = ring;
    
    %% RANSAC and MLS
    
    ptCloudSource = pointCloud([xyz_cloud(:,1), xyz_cloud(:,2), xyz_cloud(:,3)], 'Intensity',  xyz_cloud(:,4));
    x_ptA                       = ptCloudSource.Location(:,1);
    y_ptA                       = ptCloudSource.Location(:,2);
    z_ptA                       = ptCloudSource.Location(:,3);
    xyz_mll                     = [x_ptA y_ptA z_ptA];
    model_MLS                   = MLL_plane_proj(xyz_mll(isfinite(xyz_mll(:,1)), :));
    % RANSAC - MATLAB
%     maxDistance                 = 0.5;
    model_RANSAC                = pcfitplane(ptCloudSource, maxDistance);

    %% Doing Other Stuff
    
    % Eliminate points
%     xyz_cloud(xyz_cloud(:,5) < ring_max, :) = [];
%     xyz_cloud(xyz_cloud(:,5) > ring_min, :) = [];

%     xyz_cloud(sqrt(xyz_cloud(:,1).^2 + xyz_cloud(:,2).^2 + xyz_cloud(:,3).^2) <= min_dist, :) = [];
%     xyz_cloud(sqrt(xyz_cloud(:,1).^2 + xyz_cloud(:,2).^2 + xyz_cloud(:,3).^2) >= max_dist, :) = [];
    
    
    % Eliminiating infs and nans from the xyz data - there may be a way to
    % use the 
    xyz_cloud                   = xyz_cloud( ~any( isnan(xyz_cloud) | isinf(xyz_cloud), 2),:);
    
    % Transforming the point cloud
    tform                       = rigid3d(rotate_update, [lidarTrajectory(1) lidarTrajectory(2) lidarTrajectory(3)]);
    
    % EXPERIMENT sort rows
    xyz_cloud = sortrows(xyz_cloud,5);
    
    % Creating the point cloud object
%     pointClouXYZI_curr          = pointCloud([xyz_cloud(:,1), xyz_cloud(:,2), xyz_cloud(:,3)], 'Intensity',  xyz_cloud(:,4));
%     pointClouXYZI_curr          = pctransform(pointClouXYZI_curr, tform);
    
    %% Grabbing the training data from the point cloud
    [data_a data_b] = grab_training_data(xyz_cloud, tform, Manual_Classfied_Areas, model_RANSAC, model_MLS, save_folder, terrain_opt, roi_select);
    
    raw_data_export = [raw_data_export; data_a; data_b];
    
    % Plotting gps/lidar frames
%     gps_pos_store(cloud,:)      = groundTruthTrajectory;
%     lidar_pos_store(cloud,:)    = lidarTrajectory;
    
    %% Save point cloud
%     pointCloudList{cloud}       = pointClouXYZI_curr;
    
    % alternate method - eliminates points though 
%     mergeGridStep = 0.1;
%     pointCloudList = pcmerge(pointCloudList, pointClouXYZI_curr, mergeGridStep);
    
    %% Break Condition
    
    if cloud > cloud_break
        break
    end
    
    %% Weightbar
    
    waitbar(cloud/length(lidar_msgs), h, sprintf("%0.0f / %0.0f Clouds", cloud, length(lidar_msgs)))
    

end

delete(h)

%% save the raw_data_export

Filename        = save_folder + "/raw_data_export_" + string(time_now) + "_" + string(terrain_type) + "_" + string(roi_select) + ".mat";

save(Filename, 'raw_data_export')


%% Compiling the map
% 
% disp("Making the map, sire...")
% pointCloudList = pccat([pointCloudList{:}]);

%% Displaying the map
% 
% hold on
% 
% % Plotting the line between the lidar and gps
% for point = 1:length(lidar_pos_store)
%     
%     plot3([lidar_pos_store(point,1) gps_pos_store(point,1)],...
%           [lidar_pos_store(point,2) gps_pos_store(point,2)],...
%           [lidar_pos_store(point,3) gps_pos_store(point,3)],...
%           'linewidth',3)
%       
% end
% 
% % Plotting the lidar and gps points
% scatter3(gps_pos_store(1,1),gps_pos_store(1,2),gps_pos_store(1,3),420,'^','MarkerFaceColor','yellow')
% scatter3(gps_pos_store(end,1),gps_pos_store(end,2),gps_pos_store(end,3),420,'^','MarkerFaceColor','blue')
% scatter3(gps_pos_store(:,1),gps_pos_store(:,2),gps_pos_store(:,3),50,'^','MarkerFaceColor','magenta')
% scatter3(lidar_pos_store(:,1),lidar_pos_store(:,2),lidar_pos_store(:,3),50,'^','MarkerFaceColor','cyan')
% 
% % Plotting the point cloud
% pcshow(pointCloudList);
% 
% view([0 0 90])

%% Save the PCD
% 
% save_ans = questdlg('Save pcd?', 'Save pcd?', 'Yes', 'No', 'No');
% 
% switch save_ans
%     
%     case 'Yes'
%         
%         name_ans        = inputdlg({'Enter Filename:'}, 'Filename', [1 35], {'pcd.pcd'});
%         name_ans        = name_ans{:};
%                 
%         export_dir      = uigetdir();
%         PCDFileName     = fullfile(export_dir, name_ans);
%         
%         pcwrite(pointCloudList,PCDFileName)
%         
%     case 'No'
%         
%         warning('WILL NOT SAVE THE PCD!')
%         
% end

%% End Program 

% web('https://www.youtube.com/watch?v=DPBvMsT3prg&ab_channel=AdesRizaTV')

% gong_gong()

disp('End Program!')



